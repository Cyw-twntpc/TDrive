const TransferManager = {
    uploads: new Map(),
    downloads: new Map(), // Top-level tasks (files or folders)
    updateInterval: null,
    minimizeTimeout: null,
    isPanelMinimized: false,
    hadActiveTransfers: false,
    concurrencyLimit: 3,
    currentDownloadDestination: '',
    AppState: null,
    ApiService: null,
    UIHandler: null,
    refreshCallback: null,

    // --- 初始化 ---
    initialize(AppState, ApiService, UIHandler, refreshCallback) {
        this.AppState = AppState;
        this.ApiService = ApiService;
        this.UIHandler = UIHandler;
        this.refreshCallback = refreshCallback;
        this.setupEventListeners();
        
        // Connect to the backend signal for progress updates
        if (window.tdrive_bridge && window.tdrive_bridge.transfer_progress_updated) {
            window.tdrive_bridge.transfer_progress_updated.connect(this.updateTask.bind(this));
            console.log("TransferManager connected to backend transfer_progress_updated signal.");
        }
    },

    // --- 任務管理 (支援樹狀結構) ---
    addDownload(item) {
        console.log('[DEBUG] TransferManager.addDownload called with:', JSON.parse(JSON.stringify(item)));
        // item now contains task_id, db_id, name, type, size
        if (this.downloads.has(item.task_id)) {
            console.warn(`[DEBUG] Download task with id ${item.task_id} already exists.`);
            return;
        }
        const task = { 
            id: item.task_id, // 使用 UUID 作為主要 ID
            db_id: item.db_id, // 保留資料庫 ID
            name: item.name, 
            size: item.size || 0, 
            progress: 0, 
            speed: 0, 
            status: 'queued',
            isFolder: item.type === 'folder',
            parentFolderId: this.AppState.currentFolderId, // Explicitly store the parent ID
            children: item.type === 'folder' ? new Map() : null,
            total_files: item.type === 'folder' ? 0 : 1,
            completed_files: 0,
            expanded: true, 
            feedbackShown: false, 
            alertShown: false, 
            itemData: item
        };
        this.downloads.set(item.task_id, task); // 使用 task_id 作為 map 的 key
        console.log(`[DEBUG] Added new download task. Current downloads map size: ${this.downloads.size}`);
        this.startUpdater();
    },

    // [FIXED] Use a unique ID for uploads instead of the filename
    addUpload(fileData) {
        // [FIXED] Use the task_id generated by main.js, do not generate a new one here.
        const task_id = fileData.task_id;
        if (this.uploads.has(task_id)) return;

        const task = { 
            id: task_id, 
            name: fileData.name, 
            size: fileData.size || 0, 
            progress: 0, 
            speed: 0, 
            status: 'queued', 
            isFolder: false,
            localPath: fileData.localPath, 
            parentFolderId: fileData.parentFolderId,
            feedbackShown: false, 
            alertShown: false 
        };
        this.uploads.set(task_id, task);
        this.startUpdater();
    },
    
    updateTask(data) {
        console.log('[DEBUG] updateTask received data from backend:', JSON.parse(JSON.stringify(data)));
        let task;
        let parentTask = null;

        if (data.parent_id) {
            parentTask = this.downloads.get(data.parent_id);
            if (parentTask && parentTask.children) {
                task = parentTask.children.get(data.id);
                if (!task) {
                    // This can happen if a child update arrives before the 'starting_folder' event.
                    // It's safe to ignore it, as the 'starting_folder' event will establish the ground truth,
                    // and subsequent progress updates will find the task correctly.
                    console.warn(`[TM] Ignoring premature update for child task ${data.id}.`);
                    return;
                }
            } else {
                // If the parent or its children map don't exist yet, we can't process this update.
                return;
            }
        } else {
            task = this.downloads.get(data.id) || this.uploads.get(data.id);
        }

        if (!task) {
            console.error(`[DEBUG] CRITICAL: updateTask could not find a matching task for id: ${data.id}`);
            return;
        }
        
        // [REMOVED] The complex and fragile ID-swapping logic is no longer needed.

        if (data.status === 'starting_folder' && task.isFolder) {
            Object.assign(task, data);
            task.children = new Map();

            // Helper map to quickly find folder nodes by their relative path
            const folderNodes = new Map();
            folderNodes.set('', task); // The root of this download is at path ''

            // Sort children by path depth to ensure parent folders are created before their children
            const sortedChildren = (data.children || []).sort((a, b) => a.relative_path.length - b.relative_path.length);

            sortedChildren.forEach(childInfo => {
                const pathParts = childInfo.relative_path.replace(/\\/g, '/').split('/');
                const fileName = pathParts.pop();
                const parentPath = pathParts.join('/');

                const parentNode = folderNodes.get(parentPath);
                if (!parentNode) {
                    console.error(`Could not find parent node for path: ${parentPath}`);
                    return;
                }
                
                const isFolder = childInfo.type === 'folder';
                const newNode = {
                    ...childInfo,
                    isFolder,
                    status: isFolder ? 'pending' : 'queued',
                    progress: 0,
                    size: childInfo.size || 0,
                    children: isFolder ? new Map() : null,
                    expanded: true,
                    alertShown: false
                };
                
                parentNode.children.set(childInfo.id, newNode);

                if (isFolder) {
                    folderNodes.set(childInfo.relative_path, newNode);
                }
            });
        } else {
            Object.assign(task, data);
        }

        if (parentTask) {
            this.updateParentProgress(parentTask);
        }

        if (task.status === 'failed' && !task.alertShown) {
            this.UIHandler.handleBackendError({ 
                error_code: 'TRANSFER_FAILED',
                message: `項目 "${task.name}" 傳輸失敗。<br><b>原因:</b> ${task.message || '未知錯誤'}`
            });
            task.alertShown = true;
        }
        this.startUpdater();
    },

    updateParentProgress(parentTask) {
        if (!parentTask || !parentTask.isFolder) return;

        const _calculateFolderStats = (folderNode) => {
            let totalProgress = 0;
            let completedFiles = 0;
            let isTransferring = false;
            let hasFailures = false;
            let totalFiles = 0;

            for (const child of folderNode.children.values()) {
                if (child.isFolder) {
                    const stats = _calculateFolderStats(child);
                    totalProgress += stats.totalProgress;
                    completedFiles += stats.completedFiles;
                    if (stats.isTransferring) isTransferring = true;
                    if (stats.hasFailures) hasFailures = true;
                    totalFiles += stats.totalFiles;
                } else { // It's a file
                    totalFiles++;
                    totalProgress += child.progress || 0;
                    if (child.status === 'completed') {
                        completedFiles++;
                    } else if (child.status === 'failed' || child.status === 'cancelled') {
                        hasFailures = true;
                    } else if (child.status === 'transferring' || child.status === 'queued') {
                        isTransferring = true;
                    }
                }
            }
            return { totalProgress, completedFiles, isTransferring, hasFailures, totalFiles };
        };

        const stats = _calculateFolderStats(parentTask);
        
        parentTask.progress = stats.totalProgress;
        parentTask.completed_files = stats.completedFiles;
        // The total_files from backend is for files only, which matches our recursive calculation
        // parentTask.total_files = stats.totalFiles; 

        if (stats.hasFailures) {
            parentTask.status = 'failed';
        } else if (stats.completedFiles === parentTask.total_files && parentTask.total_files > 0) {
            parentTask.status = 'completed';
        } else if (stats.isTransferring) {
            parentTask.status = 'transferring';
        } else {
            // Not failed, not complete, but not transferring either (e.g., all queued)
            // Keep status as is (e.g., 'starting_folder') until a file starts transferring
        }
    },
    
    startUpdater() {
        if (!this.updateInterval) {
            this.updateInterval = setInterval(() => this.tick(), 1000);
        }
        this.showPanel();
        this.updateAllUI(); // Trigger immediate update so content is visible right away
    },
    
    tick() {
        this.updateAllUI();
        const allTransfers = [...this.uploads.values(), ...this.downloads.values()];
        if (allTransfers.length === 0) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
            this.hidePanel();
        }

        const completedOrFailedTasks = allTransfers.filter(t => (t.status === 'completed' || t.status === 'failed') && !t.feedbackShown);
        if(completedOrFailedTasks.length > 0) {
            this.refreshCallback().then(() => {
                completedOrFailedTasks.forEach(task => {
                    if (!task.isFolder) {
                         this.showFileFeedback(task.name, task.status);
                    }
                    task.feedbackShown = true;
                });
            });
        }
    },

    scheduleMinimize() {
        if (this.minimizeTimeout) clearTimeout(this.minimizeTimeout);
        this.minimizeTimeout = setTimeout(() => {
            const panel = document.getElementById('transfer-summary-panel');
            if (panel && !panel.matches(':hover') && !document.getElementById('transfer-details-modal').matches(':hover')) {
                 panel.classList.add('minimized');
                 this.isPanelMinimized = true;
            }
        }, 3000);
    },

    updateAllUI() {
        this.updateSummaryPanel();
        this.updateDetailsModal();
        this.updateMainFileListUI();
    },

    showPanel() {
        document.getElementById('transfer-summary-panel').classList.remove('hidden');
    },
    
    hidePanel() {
        document.getElementById('transfer-summary-panel').classList.add('hidden');
    },

    updateSummaryPanel() {
        const uploadsPanel = document.getElementById('summary-uploads');
        const downloadsPanel = document.getElementById('summary-downloads');
        
        // --- 上傳邏輯 ---
        if (this.uploads.size > 0) {
            uploadsPanel.classList.remove('hidden');
            let totalUploadProgress = 0, totalUploadSize = 0, activeUploads = 0;

            this.uploads.forEach(task => {
                if (task.status !== 'failed' && task.status !== 'cancelled') {
                    totalUploadSize += task.size;
                    totalUploadProgress += (task.status === 'completed') ? task.size : task.progress;
                }
                if (task.status === 'transferring' || task.status === 'queued') {
                    activeUploads++;
                }
            });

            const uploadProgressBar = document.getElementById('summary-uploads-progress');
            const uploadPercent = totalUploadSize > 0 ? (totalUploadProgress / totalUploadSize * 100) : 0;
            uploadProgressBar.style.width = `${uploadPercent}%`;

            let uploadTitle = `上傳中 ${activeUploads} 個項目...`;
            let uploadProgressClass = '';

            if (activeUploads === 0) {
                const hasFailures = [...this.uploads.values()].some(t => t.status === 'failed');
                const hasCancellations = [...this.uploads.values()].some(t => t.status === 'cancelled');
                
                if (hasFailures) {
                    uploadTitle = '部分項目上傳失敗';
                    uploadProgressClass = 'failed';
                } else if (hasCancellations) {
                    uploadTitle = '上傳任務已取消';
                    uploadProgressClass = 'cancelled'; // Note: 'cancelled' class is for logic, can be styled if needed
                } else {
                    uploadTitle = '上傳完成';
                    uploadProgressClass = 'completed';
                }
            }
            
            document.getElementById('summary-uploads-title').textContent = uploadTitle;
            uploadProgressBar.className = 'progress-fill'; // Reset
            if(uploadProgressClass) uploadProgressBar.classList.add(uploadProgressClass);

        } else {
            uploadsPanel.classList.add('hidden');
        }

        // --- 下載邏輯 (與上傳邏輯對稱) ---
        if (this.downloads.size > 0) {
            downloadsPanel.classList.remove('hidden');
            let totalDownloadProgress = 0, totalDownloadSize = 0, activeDownloads = 0;

            this.downloads.forEach(task => {
                if (task.status !== 'failed' && task.status !== 'cancelled') {
                    totalDownloadSize += task.size;
                    totalDownloadProgress += (task.status === 'completed') ? task.size : task.progress;
                }
                if (['transferring', 'queued', 'starting_folder'].includes(task.status)) {
                    activeDownloads++;
                }
            });

            const downloadProgressBar = document.getElementById('summary-downloads-progress');
            const downloadPercent = totalDownloadSize > 0 ? (totalDownloadProgress / totalDownloadSize * 100) : 0;
            downloadProgressBar.style.width = `${downloadPercent}%`;

            let downloadTitle = `下載中 ${activeDownloads} 個項目...`;
            let downloadProgressClass = '';

            if (activeDownloads === 0) {
                const hasFailures = [...this.downloads.values()].some(t => t.status === 'failed');
                const hasCancellations = [...this.downloads.values()].some(t => t.status === 'cancelled');

                if (hasFailures) {
                    downloadTitle = '部分項目下載失敗';
                    downloadProgressClass = 'failed';
                } else if (hasCancellations) {
                    downloadTitle = '下載任務已取消';
                    downloadProgressClass = 'cancelled';
                } else {
                    downloadTitle = '下載完成';
                    downloadProgressClass = 'completed';
                }
            }

            document.getElementById('summary-downloads-title').textContent = downloadTitle;
            downloadProgressBar.className = 'progress-fill'; // Reset
            if(downloadProgressClass) downloadProgressBar.classList.add(downloadProgressClass);
            
        } else {
            downloadsPanel.classList.add('hidden');
        }

        // --- 統一處理最小化圖示的進度環 ---
        const allTasks = [...this.uploads.values(), ...this.downloads.values()];
        let combinedProgress = 0, combinedSize = 0;
        allTasks.forEach(task => {
            if (task.status !== 'failed' && task.status !== 'cancelled') {
                combinedSize += task.size;
                combinedProgress += (task.status === 'completed') ? task.size : task.progress;
            }
        });

        const overallPercent = combinedSize > 0 ? (combinedProgress / combinedSize * 100) : 0;
        const circle = document.getElementById('minimized-progress-circle');
        const radius = circle.r.baseVal.value;
        const circumference = radius * 2 * Math.PI;
        circle.style.strokeDasharray = `${circumference} ${circumference}`;
        
        if (overallPercent > 0) {
            const offset = circumference - overallPercent / 100 * circumference;
            circle.style.strokeDashoffset = offset;
        } else {
            circle.style.strokeDashoffset = circumference;
        }
    },
    
    showDetailsModal() {
        UIManager.toggleModal('transfer-details-modal', true);
        this.updateDetailsModal();
    },

    updateDetailsModal() {
        const modal = document.getElementById('transfer-details-modal');
        if (modal.classList.contains('hidden')) return;

        const renderListRecursive = (map, element, indentLevel = 0, parentId = null) => {
            // Sort items: folders first, then by name
            const sortedItems = [...map.values()].sort((a, b) => {
                if (a.isFolder && !b.isFolder) return -1;
                if (!a.isFolder && b.isFolder) return 1;
                return a.name.localeCompare(b.name, 'zh-Hans-CN-u-co-pinyin');
            });

            for (const task of sortedItems) {
                element.appendChild(this._createTaskElement(task, indentLevel, parentId));
                if (task.isFolder && task.expanded && task.children) {
                    renderListRecursive(task.children, element, indentLevel + 1, task.id);
                }
            }
        };

        const uploadListEl = document.getElementById('upload-list');
        uploadListEl.innerHTML = '';
        if (this.uploads.size === 0) {
            uploadListEl.innerHTML = '<p class="empty-list-msg">沒有上傳任務</p>';
        } else {
            renderListRecursive(this.uploads, uploadListEl);
        }

        const downloadListEl = document.getElementById('download-list');
        downloadListEl.innerHTML = '';
        if (this.downloads.size === 0) {
            downloadListEl.innerHTML = '<p class="empty-list-msg">沒有下載任務</p>';
        } else {
            renderListRecursive(this.downloads, downloadListEl);
        }

        document.getElementById('upload-count').textContent = `(${this.uploads.size})`;
        document.getElementById('download-count').textContent = `(${this.downloads.size})`;
    },

    _createTaskElement(item, indentLevel, parentId = null) {
        const row = document.getElementById('transfer-item-template').content.cloneNode(true).firstElementChild;
        row.dataset.id = item.id;
        if (parentId) row.dataset.parentId = parentId;

        row.querySelector('.item-indent').style.width = `${indentLevel * 25}px`;
        const toggle = row.querySelector('.item-toggle');
        if (item.isFolder) {
            toggle.innerHTML = `<i class="fas ${item.expanded ? 'fa-caret-down' : 'fa-caret-right'}"></i>`;
            toggle.style.cursor = 'pointer';
            toggle.addEventListener('click', () => this.toggleFolder(item.id));
        }

        row.querySelector('.file-icon').className = `file-icon ${item.isFolder ? 'fas fa-folder' : this.UIHandler.getFileTypeIcon(item.name)}`;
        row.querySelector('.item-name').textContent = item.name;
        
        const progressFill = row.querySelector('.progress-fill');
        const progressText = row.querySelector('.item-progress-text');
        const itemStatus = row.querySelector('.item-status');
        const itemSpeed = row.querySelector('.item-speed');

        const percent = item.size > 0 ? (item.progress / item.size * 100) : 0;
        progressFill.style.width = `${percent}%`;
        itemSpeed.textContent = item.speed > 0 ? `${this.UIHandler.formatBytes(item.speed)}/s` : '';

        switch (item.status) {
            case 'completed':
                progressFill.style.backgroundColor = 'var(--success-color)';
                progressText.textContent = this.UIHandler.formatBytes(item.size);
                itemStatus.innerHTML = '<i class="fas fa-check-circle"></i>';
                break;
            case 'failed':
                progressFill.style.backgroundColor = 'var(--danger-color)';
                progressText.textContent = item.message || '失敗';
                itemStatus.innerHTML = '<i class="fas fa-exclamation-circle"></i>';
                break;
            case 'transferring':
                progressText.textContent = `${this.UIHandler.formatBytes(item.progress)} / ${this.UIHandler.formatBytes(item.size)} (${percent.toFixed(1)}%)`;
                itemStatus.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                break;
            case 'starting_folder':
                progressText.textContent = `${item.completed_files} / ${item.total_files} 個檔案 (${this.UIHandler.formatBytes(item.size)})`;
                itemStatus.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                break;
            case 'queued':
                progressText.textContent = '佇列中...';
                itemStatus.innerHTML = '<i class="fas fa-clock"></i>';
                break;
            case 'cancelled':
                progressText.textContent = '已取消';
                itemStatus.innerHTML = '<i class="fas fa-times-circle" style="color: var(--danger-color);"></i>';
                break;
            default:
                 progressText.textContent = '...';
                 itemStatus.innerHTML = '<i class="fas fa-question-circle"></i>';
        }
        return row;
    },

    toggleFolder(taskId) {
        const result = this.findTask(taskId);
        if (result && result.task && result.task.isFolder) {
            result.task.expanded = !result.task.expanded;
            this.updateDetailsModal();
        }
    },
    
    updateMainFileListUI() {
        document.querySelectorAll('.file-item:not(.is-uploading)').forEach(el => {
            const name = el.dataset.name;
            let task = null;

            const findTaskByNameAndParent = (taskMap) => {
                for (const t of taskMap.values()) {
                    if (t.name === name && t.parentFolderId === this.AppState.currentFolderId) {
                        return t;
                    }
                }
                return null;
            };

            task = findTaskByNameAndParent(this.uploads) || findTaskByNameAndParent(this.downloads);

            el.classList.remove('in-transfer');
            if (el.querySelector('.transfer-overlay-icon')) el.querySelector('.transfer-overlay-icon').remove();
            
            if(task && ['transferring', 'paused', 'queued', 'starting_folder'].includes(task.status)) {
                el.classList.add('in-transfer');
            }
        });
    },

    showFileFeedback(name, status) {
        const el = document.querySelector(`.file-item[data-name="${CSS.escape(name)}"]`);
        if (!el) return;
        el.classList.remove('in-transfer');
        const flashClass = status === 'completed' ? 'flash-success' : 'flash-fail';
        el.classList.add(flashClass);
        setTimeout(() => el.classList.remove(flashClass), 1000);
    },

    findTask(id) {
        const _findRecursive = (searchId, map, parent = null) => {
            for (const task of map.values()) {
                if (task.id === searchId) {
                    return { task, map, parent };
                }
                if (task.isFolder && task.children) {
                    const result = _findRecursive(searchId, task.children, task);
                    if (result) {
                        return result;
                    }
                }
            }
            return null;
        };

        return _findRecursive(id, this.uploads) || _findRecursive(id, this.downloads);
    },
    
    cancelItem(id) {
        const result = this.findTask(id);
        if (result) {
            if (['transferring', 'queued'].includes(result.task.status)) {
                // Use the ApiService to send the cancel request
                this.ApiService.cancelTransfer(id).then(res => {
                    if (!res.success) {
                        console.warn(`Failed to cancel task ${id}:`, res.message);
                    }
                });
            }
            const map = result.parent ? result.parent.children : result.map;
            
            const key = result.task.id;

            if (map.has(key)) {
                map.delete(key);
            } else {
                console.warn(`Cancel failed: key "${key}" not found in map.`);
            }
            this.tick();
        }
    },

    cancelAll() {
        const _cancelRecursively = (map) => {
            map.forEach(task => {
                // Cancel children first
                if (task.isFolder && task.children) {
                    _cancelRecursively(task.children);
                }
                // Cancel the item itself (backend only cares about file tasks, but this is for UI cleanup)
                this.cancelItem(task.id);
            });
        };
        _cancelRecursively(this.uploads);
        _cancelRecursively(this.downloads);
    },

    clearCompleted() {
        const _filterRecursively = (map) => {
            for (let [key, task] of map.entries()) {
                if (task.isFolder && task.children) {
                    _filterRecursively(task.children);
                }
                if (['completed', 'failed', 'cancelled'].includes(task.status)) {
                    map.delete(key);
                }
            }
        };
        _filterRecursively(this.uploads);
        _filterRecursively(this.downloads);
        this.tick();
    },

    setConcurrencyLimit(limit) { this.concurrencyLimit = limit; },
    getConcurrencyLimit() { return this.concurrencyLimit; },
    setDownloadDestination(path) { this.currentDownloadDestination = path; },
    
    setupEventListeners() {
        const panel = document.getElementById('transfer-summary-panel');
        const minimizedIcon = document.getElementById('minimized-transfer-icon');
        minimizedIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            panel.classList.remove('minimized');
            this.isPanelMinimized = false;
        });
        panel.addEventListener('mouseenter', () => clearTimeout(this.minimizeTimeout));
        panel.addEventListener('mouseleave', () => this.scheduleMinimize());
        document.getElementById('show-details-btn').addEventListener('click', () => this.showDetailsModal());
        document.getElementById('close-modal-btn').addEventListener('click', () => UIManager.toggleModal('transfer-details-modal', false));
        document.getElementById('cancel-all-btn').addEventListener('click', () => this.cancelAll());
        document.querySelectorAll('.modal-tabs .tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelector('.modal-tabs .tab-btn.active').classList.remove('active');
                btn.classList.add('active');
                document.querySelector('.tab-content.active').classList.remove('active');
                document.getElementById(`${btn.dataset.tab}-tab`).classList.add('active');
            });
        });
        document.getElementById('clear-completed-btn').addEventListener('click', () => this.clearCompleted());
    }
};